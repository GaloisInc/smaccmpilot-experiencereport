\section{The Good}

In this section, we discuss some of the surprising benefits of using EDSLs for
embedded programming, focusing on those that were surprising to us, despite our
teams' previous experience in functional programming and embedded development.

\paragraph{Type-checking as interpretation}
Build times are non-trivial for large software systems.  (Some of our kernel
developers at Galois are known to have novels on hand to read during the build
and test cycle.)  At the time of writing, a fresh build of SMACCMPilot and
associated test programs is \lp{XXX} minutes.  One reason the build time is so
large is that it requires Cabal (the Haskell package manager) to discover
library dependencies and install packages, compiler the Haskell sources, and
then compile the C sources.

In addition, during testing
and integration, our build includes various test builds and builds for multiple
operating-system and hardware configurations meaning that the same source code
gets recompiled multiple times.

Then, to execute the software on the embedded device, we have to write the
software to the device's memory (we refer to this as ``flashing'' the device,
since the executable is stored in non-volatile flash memory on a number of
microcontrollers).  Flashing can take many seconds.

All this is to say that the time between making a change in the sources to when
the changes are tested can be many seconds or minutes.  The situation is
exacerbated when we use an EDSL to generate the C code; the EDSL must be
compiled by Haskell; the haskell program is executed to generate the C code, and
then the C code is compiled, linked, and flashed.

High-level languages like Haskell have a read-eval-print-loop (REPL),
significantly reducing development time since it allows the developer to
type-check and test programs without going through the full compilation cycle.
Embedded C does not have a REPL, and building one is a major undertaking: it
would require a model of the sensors and devices the program interacts with, a
model of the operating system, as well as library code (e.g.,
glibc).\footnote{An emulator like QEMU~\cite{} does not solve the problem: (1)
  QEMU is not an interpreter, and often it is not useful at all if the
  application code interacts with sensors and external devices.}



\paragraph{Mario programming}
We are all just plumbers.

\paragraph{The 7-minute driver}
A sports science research article has recently popularized the idea of a
``7~minute workout'' that is short but intense~\cite{}.  We 


Safe drivers as easy as user-code.  (Note Microsoft focus on drivers)

\lp{no seg faults}


