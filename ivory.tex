\section{Ivory: Safe C Programming}
\label{sec:ivory}

At face value, our approach sounds audacious if not ludicrous: faced with a
deadline for developing a new high-assurance autopilot system in one-and-a-half
years, start by designing a new programming language and compiler from the
ground up.

Of course, developing an EDSL is not the same as developing a stand-alone
compiler.  Much of the typical compiler tool-chain, such as the front-end
parser/lexer, is obviated.  Furthermore, we were confident that time spent in
writing the EDSL would be made up by developing in a high-level functional
language with a rich set of existing libraries.

The language we developed for generating safe embedded C code is called
\emph{Ivory}.  Ivory shares the goal of other ``safe-C'' standalone languages
and compilers like Cyclone~\cite{cyclone}, BitC~\cite{bitc}, and
Rust~\cite{rust}.  Our main motivation for not using these languages is to have
the benefits of an EDSL and particularly our desire for a Turing-complete,
type-safe macro-language to improve our productivity.

There have also been some ``safe-C'' EDSLs including Atom~\cite{atom},
Copilot~\cite{copilot}, and FeldSpar~\cite{feldspar1}.  The most significant
difference between these languages and Ivory is that they are focused on pure
computations and do not provide convenient support for defining in-memory
data-structures and manipulating memory.  Ivory is designed to be a
general-purpose embedded C EDSL that can be used for memory-manipulation
intensive programs, such as device drivers.

The essential contributions of Ivory from a programming language perspective are
its expressiveness and our approach to type-safety.

\paragraph{Expressiveness}
Regarding the expressiveness, Ivory has a number of features:

\begin{compactitem}
  \item \emph{Memory-areas}: the ability to allocate stack-based memory and
    manipulate both local and global memory areas~\cite{memareas}.
  \item \emph{Product types}: C structs with well-typed accessors.
  \item \emph{FFI}: typed interfaces for calling arbitrary C functions.
  %% \item \emph{Module system}: managing dependencies to support C-level headers
  %%   and includes.
  \item \emph{Bit-fields}: support for typed manipulation of bit-fields and
    registers~\cite{high-level}.
\end{compactitem}

As well, Ivory has some limitations, motivated by making analysis simpler to
ensure safe C programs are generated.  Ivory does not support heap-based dynamic
memory allocation (but global variables can be defined).  C arrays are
fixed-length.  There is no pointer arithmetic.  Pointers are non-nullable.
Union types are not supported.  Unsafe casts are not supported: casts must to a
strictly more expressive type (e.g., from an unsigned 8-bit integer to an
unsigned 16-bit integer) or a default value must be provided that is returned
for casts otherwise.  In particular, no void-type exists.

In Ivory, these have not been limiting factors, particularly because of the
power of using Haskell as a macro system.  For example, while arrays must be of
fixed size at C compile-time, we can define a single \emph{Haskell} function
that is polymorphic in the array size that becomes instantiated at a particular
size at each use site.  %% An array has the type

%% \begin{code}
%% Array (n::Nat) t
%% \end{code}

\paragraph{Type-level properties}
Ivory's domain-specific type checking focuses essentially on guaranteeing memory
safety and helping the programmer reason about her programs' nonfunctional
behaviors more easily.  With respect to memory safety, the essential
guarantees necessary, for our restricted form of C, are that
\begin{compactitem}
  \item null pointers are never dereferenced;
  \item array indexing occurs only within the memory allocated to
    the array;
  \item no dangling pointers are possible; in particular, a function should not
    return a pointer to memory allocated within its own stack frame.
\end{compactitem}

\noindent
Our claim is that for the fragment of C generated, these type checks are
sufficient to guarantee generated programs are memory safe (a forthcoming paper
will make this argument explicit).

In addition, Ivory programs have an \emph{effects} type associated with them.
There are three kinds of effects tracked:
\begin{compactitem}
  \item \emph{Allocation effects}: whether a program performs (stack-based)
    memory allocation as well as whether pointers point into global or stack memory.
  \item \emph{Return effects}: whether a program contains a \cd{return} statement.
  \item \emph{Break effects}: whether a program contains a \cd{break}
    statement.
\end{compactitem}
\noindent
Tracking allocation effects helps in reasoning about memory usage, but the main
benefit is to reason about data provenance for pointers: pointers into a stack
frame cannot effect global memory.  Return and break statements fundamentally
effect control-flow and can result in unexpected behavior by breaking out of the
current block or returning from a function.  Such effects are particularly
dangerous in the context of an EDSL in which programs are generated and
manipulated heavily in the host language.

In an EDSL, we have two options for type checking: (1) write a domain-specific
type-checker \emph{in} Haskell (relying on Haskell's type-system just for
macro-level type-checking), or (2) embed the domain-specific type checker into
Haskell's type checker.

For a large system such as SMACCMPilot, the development times are substantial.
Therefore, our goal is to learn about program errors early, motivating us to
pursue option (2).  (We discuss the issues of finding errors early on in more
detail in Section~\ref{}.)

Our hypothesis when developing Ivory was that the type-level extensions to the
version of Haskell supported by the Glasgow Haskell Compiler make it feasible to
embed the type-checks necessary to ensure memory-safe C programming into the
type system~\cite{dephaskell}.  From a practical standpoint, doing so
demonstrates just how far the type-system has come, allowing us to replicate the
type safety of compilers like Cyclone, etc. without implementing our own type
checker.

\begin{figure*}
  \begin{tabular}{p{0.38\textwidth}|p{0.32\textwidth}|p{0.30\textwidth}}
    \begin{smcode}
-- Type-level effects
data RetEff   = forall r. Ret r | NoRet
data AllocEff = forall s. Scope s | NoAlloc
data Effects  = Effects AllocEff RetEff

-- Type families as record selectors
type family GetRet (effs :: Effects) :: RetEff
type instance GetRet (`Effects s r) = r

type family GetAlloc (effs :: Effects) :: AllocEff
type instance GetAlloc (`Effects s r) = s

-- Helper for function effects
type FnEffects s r =
  `Effects (Scope s) (Ret r)

-- Ivory monad
newtype Ivory (eff :: Effects) a = Ivory (...)
  deriving Monad

-- Function body constructor
newtype Body r = Body
  \{ runBody :: forall s.
       Ivory (FnEffects s r) () \}
    \end{smcode} &
    \begin{smcode}
-- Memory References
data RefScope =
  Global | forall s. Stack s

data Ref (ref :: RefScope) a = Ref

-- The Tiny-Ivory language
ret :: (GetRet eff \(\sim\) Ret r)
    => r -> Ivory eff ()
ret r = ...

local :: (GetAlloc eff \(\sim\) Scope s)
      => Ivory eff (Ref (Stack s) a)
local = ...

deref :: Ref ref a -> Ivory eff a
deref ref = ...

    \end{smcode} &
    \begin{smcode}
-- Example Ivory programs
i0 :: Body Integer
i0 = Body (ret 42)

i1 :: Body ()
i1 = Body (ret ())

i2 :: Body r
i2 = Body $ do
  l <- local
  v <- deref l
  ret v

i3 :: Ref (Stack s) a
   -> Body (Ref (Stack s) a)
i3 l = Body $ do
  v <- deref l
  ...
  ret l

-- Type error!
-- i4 = Body (ret =<< local)
\end{smcode}
  \end{tabular}
  \caption{Tiny-Ivory}
  \label{fig:tiny-ivory}
\end{figure*}

We do not have space to describe the full embedded type system for Ivory.  In
Figure~\ref{fig:tiny-ivory} we present Tiny-Ivory, a model of Ivory focused on
demonstrating its effects system and how we guarantee no dangling pointers to
locally-allocated memory.

\paragraph{Effects}
The effects system for Ivory is shown in the first column of
Figure~\ref{fig:tiny-ivory}.  Using the data kinds~\cite{datakinds} and type
families~\cite{typefamilies} extensions, we define a type-level record to track
effects.  Using the data kind extension to lift data types to define kinds and
types, we define a kind \cd{RetEff} with the type \cd{Ret r} denoting that an
Ivory code block contains a return statement, and if so, the type of the value
returned.  If there is no return statement, the associated type is \cd{NoRet}.
We similarly define an allocation kind containing types that denote whether
there is local or global memory allocation as well as the type of the value
allocated.  Using type families, we define rewrite rules that are type-level
record selectors that take a type of kind \cd{Effects} and returns the field (a
type) of interest.  (The tick mark disambiguates whether we use a term to denote
a type or kind; with the tick, it is used as a type.)  The approach of faking
type-level records allows us to encode an arbitrary number of effects in a
single type.  (In real Ivory, there is an additional effect tracking the use of
\cd{break} statements, and additional effects can be added in the future.)

For convenience, we define a type synonym \cd{FnEffects} corresponding to
effects for a C function: it should contain a return statement and there may be
memory allocation.

\paragraph{The Tiny-Ivory Language}
Ivory is a monadic language.  In demonstrating type-checking, the monad
implementation is not important except to note that it is parameterized by an
effects parameter.  (The Ivory monad is a writer transformer (to
record statements) over the state monad (to generate fresh names).  For the
purposes of defining Tiny-Ivory, the identity monad will do.

In the first column of Figure~\ref{fig:tiny-ivory} is the \cd{Body} data~type
that encapsulates the monadic value implementing the body of an Ivory function.
Its type parameter corresponds to the type of the value returned.  Using rank~2
quantification, we ensure the allocation type cannot escape, as we will see shortly.

We now have the machinery to define some Tiny-Ivory statements.  Here, we care
only about the types of statements, so we will leave them undefined---the value
$\bot$ is a fine implementation.  The statement \cd{ret} corresponds to the
\cd{return} statement in C.  Note that \cd{ret} always returns \cd{()}; do not
confuse monadic return and a return statement inside the DSL.  The type-equality
constraint that ensures that the \cd{Ret} field of the type-level record equals
\cd{Ret r}, corresponding to the value returned.

We can already write some Tiny-Ivory programs!  Observe in column three of
Figure~\ref{fig:tiny-ivory} the program \cd{i0} that returns an integer and
\cd{i1} that models returning void in C.

Let us add a little more machinery to model memory allocation and reference.
Returning to column~two, and again using the data kinds extension, we define the
kind \cd{RefScope} containing two types that denote the scope of allocation;
global, or stack, respectively.  The \cd{Stack} type is parameterized.

A value with the type \cd{Ref} is a reference: that is, a pointer that is
guaranteed by construction to be non-null.  The type constructor's first
parameter is the scope of the reference and the second is the type of the value
referenced.  (In the actual implementation, the type parameter of \cd{Ref} has
kind \cd{Area}, denoting all the types that can be allocated.)  In Tiny-Ivory,
we provide a trivial value constructor to define the data type.

Now we can define a \cd{local} to stack-allocate memory as well as \cd{deref} to
dereference a pointer.  Regarding \cd{local}, just like with the \cd{ret}
statement, there is a type equality constraint; this constraint ensures that the
current effects permit scope allocation.  Local returns a pointer to the
initialized memory (in Tiny-Ivory, we have omitted initializers for local
allocation).  \cd{deref} is simpler; it returns the value pointed to by a
reference.

An example using these statements is program \cd{i2} allocates a local value,
dereference it, and then return the value, which is memory safe.  As \cd{i3}
demonstrates, we can also pass a stack-allocated reference to a function, work
with it (including storing new values in the memory area), and then return the
reference, which is also memory safe.

What we cannot do, is return a locally-allocated reference, like in program
\cd{i4}.  No possible type can be given to \cd{i4}.  The ``closest'' type is
something like
\begin{code}
Body (Ref (Stack x) a)
\end{code}
\noindent
But the type variable \cd{x} must unify with the universally quantified
\cd{s} in the type of the argument to the value constructor \cd{Body}, which is
not possible.  Note that if the type of \cd{local} were instead
\begin{code}
Ivory eff (Ref Global a)
\end{code}
\noindent
The program \cd{i4} would be well-typed as
\begin{code}
Body (Ref Global a)
\end{code}
\noindent
The typing rules to prevent dangling pointers are reminiscent of behavior
STMonad~\cite{stmonad}.

\begin{code}
foo3 :: Def (`[Ref s (Array 10 (Stored Uint32))] :-> ())
foo3 = proc "foo" $ \textbackslash{}arr -> body $ do
  arrayMap $ \textbackslash{}ix -> do
    v <- deref (arr ! ix)
    store (arr ! ix) (v+1)
\end{code}
%% $

\lp{how to change effects}
\lp{A small Ivory example?}
\lp{Ivory compiler size?  implementation (front-end, back-end, opts, etc.)}


%% Memory-allocated types have a distinct kind.  The benefit of doing so is that
%% type classes with methods operating on memory areas are defined closed under .
%% The type of all data that can be allocated (either globally or locally) has kind
%% \cd{Area k}:
%% \begin{code}
%% data Area k
%%   = Array Nat (Area k)
%%   | Struct Symbol
%%   | ...
%% \end{code}
%% \noindent
%% We have elided a few additional memory area types.  Note to that the data type
%% is used only to define a kind and its types~\cite{}; we do not use \cd{Array},
%% etc. as value constructors.  The type constructor for an array type
%% takes a type-level natural number (from \cd{GHC.TypeLits}) representing its
%% length at the type-level and the type of the values contained in the array.
%% Similarly, the type constructor for a struct type takes a type-level string that
%% names the struct definition.


%% \begin{compactitem}
%% \item Brief overview of Ivory.
%% \item Note that types are embedded in GHC type-checker.
%% \item Philosophy: push errors higher into the design cycle (C runtime to C
%%   compile time to DSL runtime to typechecking time).
%% \item Insert checks into compiler.  Easy with EDSL  (blog post).
%% \end{compactitem}


%% \begin{compactenum}
%%   \item Haskell type-checking (Haskell compilation)
%%   \item Domain-specific type-checking
%%   \item C compilation
%%   \item Static analysis
%%   \item Execution
%% \end{compactenum}
