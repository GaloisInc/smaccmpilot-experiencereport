\section{Ivory: Safe C Programming}
\label{sec:ivory}

At face value, our approach sounds audacious if not ludicrous: faced with a
deadline for developing a new high-assurance autopilot system in one-and-a-half
years, start by designing a new programming language and compiler from the
ground up.

Of course, developing an EDSL is not the same as developing a stand-alone
compiler.  Much of the typical compiler tool-chain, such as the front-end
parser/lexer, is provided for free by the host language.  Furthermore, we were
confident that time spent in writing the EDSL would be made up by developing in
a high-level functional language with a rich set of existing libraries. It took
approximately 6 engineer-months to create the Ivory language and compiler, and
total of about 6000 lines of Haskell code.

The language we developed for generating safe embedded C code is called
\emph{Ivory}.  Ivory shares the goal of other ``safe-C'' standalone languages
and compilers like Cyclone~\cite{cyclone} and Rust~\cite{rust}.  Our main
motivation for not using these languages is to have the benefits of an EDSL and
particularly our desire for a Turing-complete, type-safe macro-language to
improve our productivity.

There have also been some ``safe-C'' EDSLs including Atom~\cite{atom},
Copilot~\cite{copilot}, and FeldSpar~\cite{feldspar1}.  The most significant
difference between these languages and Ivory is that they are focused on pure
computations and do not provide convenient support for defining in-memory
data-structures and manipulating memory.  Ivory is designed to be a
general-purpose embedded C EDSL that can be used for memory-manipulation
intensive programs, such as device drivers.

In an EDSL, we have two options for type checking: (1) write a domain-specific
type-checker \emph{in} Haskell (relying on Haskell's type-system just for
macro-language type-checking), or (2) embed the domain-specific type checker
into Haskell's type checker.

For a large system such as SMACCMPilot, the development times are substantial.
Therefore, our goal is to learn about program errors early, motivating us to
pursue option (2). By early, we mean that all Haskell expressions for the Ivory
language are type checked each time the Haskell source is compiled. Compared to
option (1) this means a time difference of at least 20 seconds on our
development machines, but more importantly, it ensures that even dead code that
is not part of the generated Ivory executable is type correct, and that
generalized code is type correct for all possible use cases. (We discuss the
issues of finding errors early on in more detail in Section~\ref{sec:thegood}.)

Our hypothesis when developing Ivory was that the type-level extensions to the
version of Haskell supported by the Glasgow Haskell Compiler make it feasible to
embed the type-checks necessary to ensure memory-safe C programming into the
type system~\cite{dephaskell}.  From a practical standpoint, doing so
demonstrates just how far the type-system has come, allowing us to replicate the
type safety of compilers like Cyclone, etc. without implementing our own type
checker.

The essential contributions of Ivory from a programming language perspective are
its expressiveness and our approach to type-safety.

\paragraph{Expressiveness}
Regarding the expressiveness, Ivory has a variety of useful features, including:
\begin{compactitem}
  \item \emph{Memory-areas}: the ability to allocate stack-based memory and
    manipulate both local and global memory areas~\cite{memareas}.
  \item \emph{Product types}: C structs with well-typed accessors.
  \item \emph{FFI}: typed interfaces for calling arbitrary C functions.
  %% \item \emph{Module system}: managing dependencies to support C-level headers
  %%   and includes.
  \item \emph{Bit-fields}: support for typed manipulation of bit-fields and
    registers~\cite{high-level}.
\end{compactitem}

We built Ivory with some limitations, motivated by making analysis simpler to
ensure safe C programs are generated.  Ivory does not support heap-based dynamic
memory allocation (but global variables can be defined).  C arrays are
fixed-length.  There is no pointer arithmetic.  Pointers are non-nullable.
Union types are not supported.  Unsafe casts are not supported: casts must to a
strictly more expressive type (e.g., from an unsigned 8-bit integer to an
unsigned 16-bit integer) or a default value must be provided that is returned
for casts otherwise.  In particular, no void-type exists.

In Ivory, these have not been limiting factors, particularly because of the
power of using Haskell as a macro system.  For example, while arrays must be of
fixed size at C compile-time, we can define a single \emph{Haskell} function
that is polymorphic in the array size that becomes instantiated at a particular
size at each use site.  %% An array has the type

%% \begin{code}
%% Array (n::Nat) t
%% \end{code}

\paragraph{Type-level properties}


Ivory's domain-specific type checking focuses essentially on guaranteeing memory
safety and helping the programmer reason about her programs' nonfunctional
behaviors more easily.

%% Our claim is that for the fragment of C generated, these type checks are
%% sufficient to guarantee generated programs are memory safe (a forthcoming paper
%% will make this argument explicit).

%% With respect to memory safety, the essential
%% guarantees necessary, for our restricted form of C, are that
%% \begin{compactitem}
%%   \item null pointers are never dereferenced;
%%   \item array indexing occurs only within the memory allocated to
%%     the array;
%%   \item no dangling pointers are possible; in particular, a function should not
%%     return a pointer to memory allocated within its own stack frame.
%% \end{compactitem}

In addition, Ivory programs have an \emph{effects} type associated with them.
There are three kinds of effects tracked:
\begin{compactitem}
  \item \emph{Allocation effects}: whether a program performs (stack-based)
    memory allocation as well as whether pointers point into global or stack memory.
  \item \emph{Return effects}: whether a program contains a \cd{return} statement.
  \item \emph{Break effects}: whether a program contains a \cd{break}
    statement.
\end{compactitem}
\noindent
Tracking allocation effects helps in reasoning about memory usage, but the main
benefit is to reason about data provenance for pointers: pointers into a stack
frame cannot effect global memory.  Return and break statements fundamentally
effect control-flow and can result in unexpected behavior by breaking out of the
current block or returning from a function.  Such effects are particularly
dangerous in the context of an EDSL in which programs are generated and
manipulated heavily in the host language.

We do not have space to describe the full embedded type system, but hope to do
so in a forthcoming paper describing the Ivory language.

\paragraph{Effects}

Using the data kinds~\cite{datakinds} and type
families~\cite{typefamilies} extensions, we define a type-level record to track
effects.  Using the data kind extension to lift data types to define kinds and
types, we define a kind \cd{RetEff} with the type \cd{Ret r} denoting that an
Ivory code block contains a return statement, and if so, the type of the value
returned.  If there is no return statement, the associated type is \cd{NoRet}.
We similarly define an allocation kind containing types that denote whether
there is local or global memory allocation as well as the type of the value
allocated.  Using type families, we define rewrite rules that are type-level
record selectors that take a type of kind \cd{Effects} and returns the field (a
type) of interest.

There is an additional effect tracking the use of
\cd{break} statements, which may optionally appear only inside loop bodies.
So, some combinators in Ivory can reset effects:
\cd{break} is not permitted in procedure bodies, but introducing a loop
combinator allows \cd{break} statements to be used in that body.

The approach of faking
type-level records allows us to encode an arbitrary number of effects in a
single type.


\paragraph{Programming Interface}

We implemented several distinct programming interfaces to take care of different
concerns in the Ivory language.

The basic syntax of Ivory is the statement, which make up all procedures.
Ivory statements are effectful, we used a traditional a monadic interface.
Internally, the Ivory monad is a writer transformer (to record
statements) over the state monad (to generate fresh names). As discussed above,
the Ivory monad type is parameterized by an effects to restrict effects in
statements. An example given in Figure~\ref{fig:tower-ex} is explained below.

Ivory supports user-defined sum types, which we call Struct types.  Struct types
are defined using a quasiquoter\cite{ghc-quasiquoter} interface, where the
syntax is designed to resemble C structures. The quasiquoter uses Template
Haskell\cite{ghc-templatehaskell} to define typeclass instances (which would be
tedious and error prone to define manually) required to use the Struct type in
Ivory programs. In Figure~\ref{fig:structqq}, the struct quasiquoter is used to
define the Ivory type \cd{Struct "foo\_struct"}.

\begin{figure}
    \begin{smcode}
[ivory|
struct foo\_struct
  \{ bar :: Stored Uint8
  ; baz :: Array 10 (Stored Sint16)
  \}
|]
    \end{smcode}
  \caption{Ivory Struct type definition}
  \label{fig:structqq}
\end{figure}

\begin{figure}
    \begin{smcode}
foo\_init :: Def('[]:->())
foo\_init = proc "foo\_init" $ body $ do
  store  (fg\_ref ~> bar)      1
  store ((fg\_ref ~> baz) ! 9) 2
  where
  fg\_ref :: Ref Global (Struct "foo\_struct")
  fg\_ref = addrOf foo\_global

foo\_global :: MemArea (Struct "foo\_struct")
foo\_global = area "foo\_global" Nothing

foo\_module :: Module
foo\_module = package "foo\_module" $ do
  defStruct (Proxy :: Proxy "foo_struct")
  incl foo\_init
  defMemArea foo\_global
    \end{smcode}
  \caption{Example Ivory module definition}
  \label{fig:module}
\end{figure}

One of the most difficult design decisions in the Ivory language was the
interface for the module system.

The module system was one major language feature Ivory could not inherit from
it's host language. Because Haskell does not have any mechanism for reflection
of module contents, the Ivory programmer must create modules explicitly.

In Ivory, procedures and global memory areas are ordinary Haskell values. These,
along with dependencies, type definitions, and foreign function headers, must be
listed as the contents of an Ivory module. We use a monadic interface for
building modules, but the only action supported by this \cd{ModuleM} monad
is writing: all values have type \cd{ModuleM ()}; essentially it is the same as
building a list, but with slightly more convenient syntax. The example module
definition in Figure~\ref{fig:module} shows a module that defines \cd{Struct
"foo"} from Figure~\ref{fig:structqq}, a function \cd{foo\_init}, and a global
structure \cd{foo\_global}.


Ivory modules are translated to C as a single module at a time. Due to this
restriction, the compiler cannot guarantee that each module fully describes all
of its type, function, \& memory area dependencies, because the compilation
cannot assume any knowledge of the contents of dependencies. This is for good
reason: since dependencies may be foreign (non-Ivory generated) header files,
they may not be possible to describe in the Ivory type system.

We did not pursue whole-program compilation, where an entire set of
interdependent modules could be checked against each other for consistency.
However, it is possible that changing our approach to the module system would
permit us to catch errors earlier without undue burden to the programmer. We
plan to investigate this problem further in the future.

\paragraph{Ivory example}
To give the reader a sense of what Ivory looks like, we will sketch how to
define a simple function.  There are many aspects of the language we do not have
space to show including structs, bit-data, loops, arrays, assertions, foreign
functions, etc.

Consider the first column of Figure~\ref{fig:tower-ex}.  The function takes an
integer and returns an Ivory procedure, which compiles to a C function (the
integer argument is because the function is part of a larger example, explained
in the next section).  The types of the arguments to an Ivory procedure are
recorded in a type-level list: the arguments are a reference to a Boolean and a
unsigned 32-bit value.  The polymorphic type variable \cd{s} tells us that the
reference can be to a global or local, and the \cd{Stored} type constructor
lifts value types to memory area types.  After the infix type constructor
\cd{:->} is the return type of the function---\cd{void} in this case.  In the
function's definition, the lambda abstraction corresponds to the two arguments
of the function.  Our function is simple: it creates a local variable binding
within the language assigning to \cd{even} the value of an arithmetic
expression.  The expression takes a current time, which is a multiple of the
period, and returns whether the current time divided by the period is even or
odd.  (Operators have a preceding \cd{.} or a following \cd{?} for Boolean
operators to avoid name-space collision with Haskell operators.)  The result of
the expression is stored into \cd{res} reference.


%% \begin{code}
%% foo3 :: Def (`[Ref s (Array 10 (Stored Uint32))] :-> ())
%% foo3 = proc "foo" $ \textbackslash{}arr -> body $ do
%%   arrayMap $ \textbackslash{}ix -> do
%%     v <- deref (arr ! ix)
%%     store (arr ! ix) (v+1)
%% \end{code}
%% %% $


%% Memory-allocated types have a distinct kind.  The benefit of doing so is that
%% type classes with methods operating on memory areas are defined closed under .
%% The type of all data that can be allocated (either globally or locally) has kind
%% \cd{Area k}:
%% \begin{code}
%% data Area k
%%   = Array Nat (Area k)
%%   | Struct Symbol
%%   | ...
%% \end{code}
%% \noindent
%% We have elided a few additional memory area types.  Note to that the data type
%% is used only to define a kind and its types~\cite{}; we do not use \cd{Array},
%% etc. as value constructors.  The type constructor for an array type
%% takes a type-level natural number (from \cd{GHC.TypeLits}) representing its
%% length at the type-level and the type of the values contained in the array.
%% Similarly, the type constructor for a struct type takes a type-level string that
%% names the struct definition.


%% \begin{compactitem}
%% \item Brief overview of Ivory.
%% \item Note that types are embedded in GHC type-checker.
%% \item Philosophy: push errors higher into the design cycle (C runtime to C
%%   compile time to DSL runtime to typechecking time).
%% \item Insert checks into compiler.  Easy with EDSL  (blog post).
%% \end{compactitem}


%% \begin{compactenum}
%%   \item Haskell type-checking (Haskell compilation)
%%   \item Domain-specific type-checking
%%   \item C compilation
%%   \item Static analysis
%%   \item Execution
%% \end{compactenum}
