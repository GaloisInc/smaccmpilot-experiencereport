\section{Introduction}

Embedded programming involves the lowest levels of software development.  Most
development is in C or assembly and programs interact intimately with the
hardware.  Embedded domain-specific languages (EDSLs)~\cite{} are in some sense
at the other end of the software spectrum: they are often embedded (in a
different sense of the word!) in high-level programming languages such as
Haskell or ML, and are usually used to lift the abstraction level for
programming.

While the abstraction levels are quite different, there is no in principle
reason why EDSLs cannot be used in embedded programming.  Indeed, a number of
researchers have explored these approaches, developing EDSLs such as
Atom~cite{}, Feldspar~\cite{}, Copilot~\cite{}, \todo{more}.

In this experience report, we describe lessons learned in the use of EDSLs to
build a complex embedded system: a secure autopilot called
\emph{SMACCMPilot}.\footnote{\emph{SMACCM} is an acronym for Secure
  Mathematically-Assured Composition of Control Models.} The term `autopilot'
actually understates the software system built; SMACCMPilot's use of EDSLs
includes not just the core flight control algorithms, but also device drivers,
encrypted network stack, mode logic, and concurrency and task management.  In
all, SMACCMPilot is some \todo{XXX} lines of Haskell-hosted EDSL code that
generates \todo{YYY} lines of embedded C.  SMACCMPilot is one of the largest and
most embedded system developed using the EDSL approach. 

We developed new languages and their (EDSL) compilers from scratch in
approximately \todo{XXX} engineer-months then we used them to build SMACCMPilot
in another \todo{YYY} engineer-months.

Our goal in this paper is to summarize some of our lessons-learned.  While we
use specific examples, the lessons apply more generally to industrially-large
embedded system design in EDSLs.  Our target audience includes both researchers
developing new EDSLs for low-level programming as well as practitioners
considering using EDSLs.
