\section{Tower: from Functions to Architectures}
\label{sec:tower}

\begin{figure*}[h!t]
  \begin{tabular}{p{0.33\textwidth}|p{0.33\textwidth}|p{0.33\textwidth}}
    \begin{smcode}
blink :: ChannelSource (Stored IBool)
      -> Task ()
blink chan = do
  tx  <- withChannelEmitter chan
  res <- taskLocal
  onPeriod period $ \textbackslash{}now -> do
    res <- call blinkFromTime now
    emit_ tx res
  where period = Milliseconds 100
    \end{smcode}
&
    \begin{smcode}
blinkApp :: Tower ()
blinkApp = do
  (tx,rx) <- channel
  task "blink" (blink tx)
  task "lightswitch" $
    onChannel rx $
      \textbackslash{}lit -> do
        ifte_ lit (turnOn light)
                  (turnOff light)
    \end{smcode}
&
    \raisebox{-\height}{\includegraphics[width=5.5cm]{figures/tower-example}}
  \end{tabular}
  \caption{Task (Column. 1), Tower (Col. 2), Graphviz output (Col. 3)}
  \label{fig:tower-ex}
\end{figure*}
%%$

In many embedded systems, programmers produce an entire system of software
that interacts with multiple input and output peripherals concurrently using a
real-time operating system (RTOS). Typical RTOSes provide just a few low-level
locking and signaling primitives for scheduling. Since microcontrollers do not
have the virtual memory managment units (MMUs) found on larger processors, the
RTOS kernel cannot protect any system memory against badly behaved user code.
These restrictions put significant burden on programmers: they must ensure all
tasks, and all communication between tasks, are implemented correctly.

During our initial development of SMACCMPilot, we found ourselves writing
high-quality C functions in Ivory, which guarantees memory-safety of the
generated code. But whenever we needed
``glue code'' to implement inter-process communication, initialize
data-structures, read the system clock, lock the processor, etc., we were forced
to abandon our well-typed world and tediously use C directly via Ivory's foreign
function interface.  Furthermore, the hand-written C is OS-specific, meaning it
would have to be rewritten for any OS port.

\paragraph{Extending Ivory}
The hand-written glue code was ruining both our productivity and our assurance
story. We wanted a language to describe the structure of the glue code that
would generate it for us.
Our key insight was that such an EDSL could be built as a macro over Ivory,
using Ivory's code-generation facilities, without losing anything.

From these ideas, the Tower EDSL was born. You can think of Tower as an
extension to the Ivory language, designed to deal with the specific concerns of
multithreaded software architecture. Tower still allows the programmer to use
all the low-level power of Ivory for general programming, but uses a separate
language for describing tasks and the connections between them.  This is one of
the great productivity features of working with EDSLs: if you discover the
language you are using is difficult, tricky, or unsafe for solving a particular
problem, you can easily extend that language with a library without modifying
the compiler.

In Tower, one specifies tasks and communication channels, and the Tower compiler generate correct
Ivory implementations, as well as architecture description artifacts. Tower
hides the dangerous low-level scheduling primitives from the user, and keeps
type information for channels (i.e., the datatype of the channel message),
expressed as Ivory types, in the Haskell type system.

Tower allows the programmer to describe a static graph of channels and tasks.
For the intended use case in high assurance systems, a static configuration of
channels and tasks makes it easy to reason about memory requirements, and
permits the system to be analyzed for schedulability.

\paragraph{Multiple interpreters}

In the Tower front end, the programmer specifies a system that can be compiled
to multiple artifacts.

Tower is designed to support different operating systems via a swappable
backend. Since all code that touches operating system primitives is generated by
Tower, it is easy for the user to specify a system and compile it for
different operating systems. Tower supports both the open-soure
FreeRTOS\cite{freertos} as well as the formally-verified
eChronos RTOS\cite{echronos} developed by NICTA.

Tower also has a backend which generates a system description in the Architecture
Analysis and Design Language (AADL)~\cite{SAE:AADL}. We also built a backend for
the Graphviz dot language.  These output formats make it possible to visualize,
analyze, and automatically check properties about the system.

We were pleased by the productivity improvements and correctness guarantees the
Tower language provided. In all, it took about 4 engineer-months to build Tower,
and a total of about 3000 lines of Haskell code.


\paragraph{Tower example}
\label{sec:examples}

In Figure~\ref{fig:tower-ex}, we sketch a small Tower example that is
representative of a device driver that blinks an LED.  Small simplifications to
Tower have been made in the code, eliding details relating to code generation
and backend selection.

Consider the first column of Figure~\ref{fig:tower-ex}. The \cd{blink} task is
defined to take a channel source and returns a program in the \cd{Task} monad.
The task first initializes an emitter for the channel then creates a reference
to private but globally-allocated memory.  Every 100 milliseconds, an Ivory
action is taken.  In this case, the action is to call an Ivory function that
returns a boolean given the current time. The boolean value \cd{res} is then
emitted on the channel.

In the second column the program, defined in the \cd{Tower} monad, initializes a
channel between two tasks as well as the tasks themselves.  A channel, or queue,
consists of transmit (\cd{tx}) and receive (\cd{rx}) endpoints, respectively.
The \cd{blink} task is an RTOS task that will send output to the
\cd{lightswitch} task, which toggles the LED based on the incoming Boolean
values.

In the third column, a graph of the tower program is shown, generated from the
Tower compiler's Graphviz dot output. The \cd{blink} task is has fields for
properties and communications ports, showing its periodic rate and emitter. The
\cd{lightswitch} task only has one port, the event handler created by the
\cd{onChannel} primitive. A channel, annotated with its Ivory datatype
\cd{IBool}, is shown as a directed graph edge connecting from \cd{blink}'s
emitter to \cd{lightswitch}'s event handler.


