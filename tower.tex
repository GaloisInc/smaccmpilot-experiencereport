\section{Tower: from Functions to Architectures}

Tower is a concurrency framework for composing Ivory programs. The primary
motivation for building Tower is often called the ``glue code'' problem: we
needed a way to communicate between Ivory programs in different threads.

On embedded systems, we typically do not have access to high level operating
system primitives like sockets or pipes that facilitate communication between
separate processes. Instead, all programs run as threads in the same memory
space, and a bare-bones operating system provides a few low-level primitives
(semaphores, mutexes) for sharing information between tasks and scheduling.
Building channels and event-loop based tasks based on these primitives either
requires a runtime library or lots of tricky coding by hand to implement the
various parts of the channel in the correct places.

Tower generates code to implement event loops in tasks and communication
channels between tasks. The code generation, built on top of the Ivory language,
offers safety guarantees because it does not expose the dangerous low-level
scheduling primitives to the user, and it keeps type information for channels
(i.e. the datatype of the channel message), expressed as Ivory types, in the
Haskell type system.

Tower permits the user to describe a static graph of channels and tasks. This is
a restriction of the capabilties of most operating systems, which may create and
destroy tasks or communication datastructures at run-time. However, for the
intended use case in high assurance systems, a static configuration of channels
and tasks makes it easier to reason about memory requirements, and permits
the system to be analyzed for schedulability.

The static tower graph of channels and tasks also makes it possible to
describe the system architecture to external tools. Tower has a backend which
generates a system description in the Architecture Analysis and Design Language
(AADL). Other backends, such as for the Graphviz dot language, exist as well.
These output formats make it possible to visualize, analyze, and automatically
check properties about the system, without knowing anything about Haskell,
Ivory, or Tower. This is an important feature when working with teams that may
not all be literate in the source language.

The user specifies Tower tasks and channels with a Haskell embedded DSL. The
Tower library presents a monadic interface for creating tasks and channels.
This makes it natural to use the full power of the host language as a macro
system for Tower. The user can specify their Haskell functions, types, and
modules for building system components using Tower. This permits the user to
build higher level abstractions than Tower provides, and use Haskell semantics
to get improved safety assurances about their code.

\begin{itemize}
\item system building tool
	\begin{itemize}
		\item since tower is built on top of the ivory language, you can
			build portions of systems by calling out to external c
			code.
		\item its also feasible to build complete embedded systems
			images from 100\% tower
		\item tower can be used to write device drivers - knows about
			ISRs, scheduling priority, and we can write against the
			memory mapped IO peripheral registers from Ivory
	\end{itemize}
\item porting between OSes easy
	\begin{itemize}
		\item since os primitives are only used by generated code, we
			can just implement multiple code generators to
			implement for multiple os's
		\item currently, tower supports a backend for FreeRTOS and the
			eChronos RTOS made by NICTA.
	\end{itemize}
\end{itemize}
