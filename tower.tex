\section{Tower: from Functions to Architectures}

Tower is a concurrency framework for composing Ivory programs. The primary
motivation for building Tower is often called the ``glue code'' problem: we
needed a way to communicate between Ivory programs in different threads.

On embedded systems, we typically do not have access to high level operating
system primitives like sockets or pipes that facilitate communication between
separate processes. Instead, all programs run as threads in the same memory
space, and a bare-bones operating system provides a few low-level primitives
(semaphores, mutexes) for sharing information between tasks and scheduling.
Building channels and event-loop based tasks based on these primitives either
requires a runtime library or lots of tricky coding by hand to implement the
various parts of the channel in the correct places.

Tower generates code to implement event loops in tasks and communication
channels between tasks. The code generation, built on top of the Ivory language,
offers safety guarantees because it does not expose the dangerous low-level
scheduling primitives to the user, and it keeps type information for channels
(i.e. the datatype of the channel message), expressed as Ivory types, in the
Haskell type system.

Tower permits the user to describe a static graph of channels and tasks. This is
a restriction of the capabilties of most operating systems, which may create and
destroy tasks or communication datastructures at run-time. However, for the
intended use case in high assurance systems, a static configuration of channels
and tasks makes it easier to reason about memory requirements, and permits
the system to be analyzed for schedulability.

The static tower graph of channels and tasks also makes it possible to
describe the system architecture to external tools. Tower has a backend which
generates a system description in the Architecture Analysis and Design Language
(AADL). Other backends, such as for the Graphviz dot language, exist as well.
These output formats make it possible to visualize, analyze, and automatically
check properties about the system, without knowing anything about Haskell,
Ivory, or Tower. This is an important feature when working with teams that may
not all be literate in the source language.

The user specifies Tower tasks and channels with a Haskell embedded DSL. The
Tower library presents a monadic interface for creating tasks and channels.
This makes it natural to use the full power of the host language as a macro
system for Tower. The user can specify their Haskell functions, types, and
modules for building system components using Tower. This permits the user to
build higher level abstractions than Tower provides, and use Haskell semantics
to get improved safety assurances about their code.

Tower expects tasks to be structured as an event loop, with a callback specified
in Ivory to handle each event. Tower tasks traditionally register channels and
timers as event sources. Tower also has a facility for registering callbacks on
external events, which, with some help from a platform-specific backend, can
be used to handle hardware interrupts. Combined with Ivory extensions for safe
hardware register manipluation, we have implemented several low-level peripheral
drivers for the STM32F4 microcontroller in Tower.

Since Tower has a complete description of both the task glue code and Ivory
implementation, a top level description of a system can be used directly to
generate all of the C code for a microsystem system image.

Tower is designed to support different operating systems via a swappable
backend. Since all code that touches operating system primitives is generated by
Tower, it is trivial for the user to specify a system and compile it for
different operating systems. Tower was first designed to support FreeRTOS, a
popular open source RTOS for embedded systems. We have since added support for
the eChronos operating system, an RTOS under development by NICTA.
